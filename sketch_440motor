

/* The following code was prepared by the team at vitaMotu for the Hermes Camera Motion Controller.
   Prepare for very descriptive code!
*/

// Included libraries
#include <Wire.h>
#include <SPI.h>
#include <Adafruit_MotorShield.h> // Potentially useless with accelstepper
#include <AccelStepper.h> 
#include "utility/Adafruit_PWMServoDriver.h"
#include "Adafruit_BLE_UART.h"

// Bluetooth Definitions
#define ADAFRUITBLE_REQ 10
#define ADAFRUITBLE_RDY 2  // interrupt pin
#define ADAFRUITBLE_RST 9


Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);

// Create Motor Shield Object
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_StepperMotor *myMotor = AFMS.getStepper(200,2); // getStepper(steps,stepper#)

// Wrappers for AccelStepper
void forwardstep1() {  
  myMotor->onestep(BACKWARD, SINGLE);
}
void backwardstep1() {  
  myMotor->onestep(FORWARD, SINGLE);
}

AccelStepper stepper(forwardstep1, backwardstep1);


// Declare Variables
const int maxStep = 2200; // Steps until end of rail - needs to be changed
int startStep = 0;
int endStep = 0;
int stepCount = 0;
uint8_t stepSpeed = 230;
uint8_t bluecomm = 0;
uint8_t mode = 0;
uint8_t duration = 0;
uint8_t damping = 0;
int i = 0;
uint8_t A[11];
uint8_t error = 0;
uint8_t loopC = 0;

/******************Setup Loop************************/
void setup() {
  Serial.begin(9600);
  Serial.println("Yay 440");

  // Motor and Motor Shield Declarations
  AFMS.begin(); // Put frequency as argument
  stepper.setMaxSpeed(100); // Default rpm
  stepper.setAcceleration(100); // Default acceleration
  stepper.moveTo(2000); // Default Steps
  
  // Bluetooth Serial Declarations
  BTLEserial.setDeviceName("HERMES"); // 7 characters max
  BTLEserial.begin();
}
/*****************************************************/

aci_evt_opcode_t laststatus = ACI_EVT_DISCONNECTED;

/*****************Main Function***********************/
void loop() {
  
   // Tell the nRF8001 to do whatever it should be working on.
  BTLEserial.pollACI();

  // Ask what is our current status
  aci_evt_opcode_t status = BTLEserial.getState();
  // If the status changed....
  if (status != laststatus) {
    // print it out!
    if (status == ACI_EVT_DEVICE_STARTED) {
        Serial.println(F("* Advertising started"));
    }
    if (status == ACI_EVT_CONNECTED) {
        Serial.println(F("* Connected!"));
    }
    if (status == ACI_EVT_DISCONNECTED) {
        Serial.println(F("* Disconnected or advertising timed out"));
    }
    // Set the last status
    laststatus = status;
  }

  if (status == ACI_EVT_DEVICE_STARTED) { // CHANGED FROM ACI_EVT_CONNECTED
   
    // OK while we still have something to read, get a character and print it out
    while ((BTLEserial.available()) && (status == ACI_EVT_CONNECTED)) {
     
      // Obtain characters loop
      while((A[10] != 0xFF)&&(A[11] != 0xFF)){       // Checking last byte in array -might- not work
      for(i=0; i<12; i++){
      A[i] = BTLEserial.read();
      Serial.print(A[i]);
        }
      i = 0; 
      }
      
      // Obtain Mode / other parameters
      mode = A[0];
      duration = A[2]|(A[3] << 8); // Does this work?
      startStep = A[4]|(A[5] << 8);
      endStep = A[6]|(A[7] << 8);
      damping = A[8];
      loopC = A[9];
      
      // Enter Mode Branching                                                                                      // Test App // Up         Down         Left         Right
      // Live Mode Loop
      if (mode == 0x00){                                                                                              // Held  // B516       B615         B714         B813
          Serial.println("Live Mode");                                                                            // Released  // B507       B606         B705         B804
          // Grab instantaneous speed
          stepSpeed = A[2];
          stepper.setMaxSpeed(stepSpeed);
          stepper.setAcceleration(70);
          stepper.moveTo(100);
          
          if (A[1] == 0x00){
            // LANC Begin Recording  
            
          }
          else if (A[1] == 0x01){
              // LANC End Recording
          }         
          else if (A[1] == 0x02){
              stepper.moveTo(50);
              if(stepCount << maxStep){
              stepper.run();
              stepCount += 50;
              }
              else{
                error = 0xOS;
              }
          }
          else if (A[1] == 0x03){
              stepper.moveTo(-500);
              stepper.run();
              stepCount -= 50;
          }
      }
      
      // Time Lapse Mode Loop
      else if (mode == 0x01){ 
          Serial.println("Time Lapse Mode"); 
          stepper.setMaxSpeed(A[2]);
          Serial.println(duration);
      
          do{
          for(i=0; i < 200; i++){
            if(status == ACI_EVT_DISCONNECTED){
            Serial.println("Phone disconnected, continuing with loop");
            //BTLEserial.write(#errorcodeDISCONNECT,2);
            error = 0xDC;
            break;
            }
            
            
            //Send LANC take picture
          }
          if (error = 0xDC){break;} // Conditional successive break
        }while(loopC = 0x01);
      }
      
       // Stop-Motion Mode Loop
       else if (mode = 0x02){
          Serial.println("Stop-Motion Mode");
          if(status == ACI_EVT_DISCONNECTED){
            Serial.println("Phone disconnected, continuing with loop");
            //BTLEserial.write(#errorcodeDISCONNECT,2);
            break;
          }
          
          
          
      }
  }
  
  // Mode loops for unconditional Bluetooth connection
  if (mode == 0x01){
    
    }
  else if (mode == 0x02){
    
    }
    
    


      // write the data
    // Bluetooth write command: sendbuffer = uint8_t, sendbuffersize =< 20; 
    // BTLEserial.write(sendbuffer, sendbuffersize);
    }
 }

/******End of code***********************************************/
/****************************************************************/
/* Error Codes
0xDC - Bluetooth Disconnect
0xOS - Overshoot # of steps


*/

