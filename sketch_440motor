/* The following code was prepared by the team at vitaMotu for the Hermes Camera Motion Controller.
   Prepare for very descriptive code!
*/

// Included libraries
#include <Wire.h>
#include <SPI.h>
#include <Adafruit_MotorShield.h> // Potentially useless with accelstepper
#include <AccelStepper.h> 
#include "utility/Adafruit_PWMServoDriver.h"
#include "Adafruit_BLE_UART.h"

// Bluetooth Definitions

Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(10, 2, 9); //ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST

// Create Motor Shield Object
Adafruit_MotorShield AFMStop(0x60); // Default address, no jumpers
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_StepperMotor *myMotor = AFMStop.getStepper(200, 2); // getStepper(steps,stepper#)

// Wrappers for AccelStepper, Single Mode
void forwardstep1(){  
  myMotor->onestep(FORWARD, SINGLE);
}
void backwardstep1(){  
  myMotor->onestep(BACKWARD, SINGLE);
}

// Wrapper for AccelStepper, Micro Mode
void forwardstep2(){
    myMotor->onestep(BACKWARD, MICROSTEP);
}
void backwardstep2(){
    myMotor->onestep(FORWARD, MICROSTEP);
}

// Create wrapped motor classes
AccelStepper stepper(forwardstep1, backwardstep1);
AccelStepper microstepper(forwardstep2, backwardstep2);

// Declare Variables
const int maxStep = 2200; // Steps until end of rail - needs to be changed
int startStep = 0;
int endStep = 0;
int stepCount = 0;
int totalStep = 0;
float microSpeed = 0;
float microAccel = 0;
uint8_t stepSpeed = 230;
uint8_t maxAccel = 175;
uint8_t mode = 0;
int duration = 0;
uint8_t damping = 0;
int i = 0;
uint8_t A[11];
uint8_t error;
uint8_t loopC = 0;
uint8_t command = 0xBB;

/******************Setup Loop************************/
void setup() {
  Serial.begin(9600);
  //Serial.println("Yay 440");

  // Motor and Motor Shield Declarations
  AFMStop.begin(); // Put frequency as argument
  AFMS.begin();
  stepper.setMaxSpeed(100); // Default rpm
  stepper.setAcceleration(100); // Default acceleration
  pinMode(4, OUTPUT); // LANC Command Line
  pinMode(5, INPUT);  // LANC Pin, listens for response
  pinMode(6, OUTPUT);
  pinMode(7, OUTPUT);
  digitalWrite(4, LOW);
  
  
  // Bluetooth Serial Declarations
 BTLEserial.setDeviceName("HERMES"); // 7 characters max
 BTLEserial.begin();
}
/*****************************************************/

aci_evt_opcode_t laststatus = ACI_EVT_DISCONNECTED;

/*****************Main Function***********************/
void loop() {
   // Tell the nRF8001 to do whatever it should be working on.
  BTLEserial.pollACI();
  digitalWrite(6, HIGH); // Turn Power LED ON
  // Ask what is our current status
  aci_evt_opcode_t status = BTLEserial.getState();
  // If the status changed....
  if (status != laststatus) {
    // print it out!
    if (status == ACI_EVT_DEVICE_STARTED) {
        Serial.println(F("* Advertising started"));
    }
    if (status == ACI_EVT_CONNECTED) {
        Serial.println(F("* Connected!"));
    }
    if (status == ACI_EVT_DISCONNECTED) {
        Serial.println(F("* Disconnected or advertising timed out"));
    }
    // Set the last status
    laststatus = status;
  }

  if (status == ACI_EVT_CONNECTED) { // CHANGED FROM ACI_EVT_CONNECTED
 
    digitalWrite(7, HIGH); // Turn Bluetooth LED ON
    // While we still have something to read, get a character and print it out
    while ((BTLEserial.available()) && (status == ACI_EVT_CONNECTED)) {

      // Bluetooth Read Package
      bluRead();
      
      // Enter Mode Branching                                                                                      
      // Live Mode Loop
      if (mode == 0x00){                                                                                              
         // Serial.println("Live Mode");
          
          if (command == 0x00){
            // LANC Begin Recording  
            REC();
          }
          else if (command == 0x01){
              // LANC End Recording7
          }         
          else if (command == 0x02){
              stepper.moveTo(2500);
              while(stepper.distanceToGo() != 0){
                stepper.run();
                stepper.setMaxSpeed(stepSpeed);
                stepper.setAcceleration(5+((1-(damping/100))*maxAccel));
                BTLEserial.pollACI();
                if(BTLEserial.available()){
                    bluRead();
                }
                if(A[1] == 0x04){
                    break;
                } 
              }
          }
          else if (command == 0x03){
              stepper.moveTo(-2500);
              while(stepper.distanceToGo() != 0){
                stepper.run();
                stepper.setMaxSpeed(stepSpeed);
                stepper.setAcceleration(5+((1-(damping/100))*maxAccel));
                BTLEserial.pollACI();
                if(BTLEserial.available()){
                    bluRead();
                }
                if(A[1] == 0x04){
                    break;
                } 
              }
          }
          else if (command == 0x05){
            stepCount = stepper.currentPosition();
            bluWrite();
          }
      }
      
      // Time-Lapse Mode Loop
      else if (mode == 0x01){ 
         // Serial.println("Time Lapse Mode"); 
          stepCount = 0;
          totalStep = abs(endStep - startStep);
          microSpeed = (totalStep*16.0)/(duration);
          microAccel = (100+((1-damping/100.0))*maxAccel);
          microstepper.setMaxSpeed(microSpeed);
          microstepper.setAcceleration(200);

          stepper.setMaxSpeed(120);
          stepper.setAcceleration(200);
         // Serial.println("Setting up position");
         
         // Set-up Position
         stepper.moveTo(startStep); 
         stepper.runToPosition(); 
         stepCount = startStep; 
         timelapse();
      }
      
       // Stop-Motion Mode Loop
       else if (mode = 0x02){
         // Serial.println("Stop-Motion Mode");
          totalStep = abs(endStep - startStep);
          totalStep = totalStep/(duration/loopC); // Amount of steps divided by interval, incremental step+
          stepper.setMaxSpeed(100);
          stepper.setAcceleration(25+(1-(damping/100))*maxAccel);
          // Set-up Position
          stepper.moveTo(startStep);
          stepper.runToPosition();
          stepCount = startStep;
          stopmotion();
      }
      
  }
  
  // Mode loops for unconditional Bluetooth connection
    if ((mode == 0x01)&&(error == 0x22)){
     //  Serial.println("Entered Bluetooth Disconnect Time Lapse Loop");
       timelapse();
    }
    
    else if ((mode == 0x02)&&(error == 0x22)){
        //Serial.println("Entered Bluetooth Disconnect Stop-Motion");
        stopmotion();
    }
  }
 }

void bluRead(){
        do{      // Looks for sync bytes at end of message
        for(i=0; i<12; i++){
        A[i] = BTLEserial.read();
        //Serial.print(A[i]); -- debugging purposes
        }
        i = 0;
      }while((A[10] != 0xFF)&&(A[11] != 0xFF)&&(BTLEserial.available()));
      
      // Obtain Mode / other parameters
      mode = A[0];
      command = A[1];
      if (mode == 0x00){
            stepSpeed = (A[2] << 8) + A[3];
            damping = A[4];
      }
      else{
           duration = (A[2] << 8) + A[3]; // Concatenates 2 unsigned integers
           startStep = (A[4] << 8) + A[5];
           endStep = (A[6] << 8) + A[7];
           damping = A[8];
           loopC = A[9];
      }
}

void bluWrite(){
     // Bluetooth write command: sendbuffer = uint8_t, sendbuffersize =< 20; 
     uint8_t sendbuffer[12];
     sendbuffer[0] = 0x00;
     sendbuffer[1] = 0x00;
     sendbuffer[2] = (stepCount >> 8);
     sendbuffer[3] = (stepCount & 0xFF);
     sendbuffer[4] = 0x00;
     sendbuffer[5] = 0x00;
     sendbuffer[6] = 0x00;
     sendbuffer[7] = 0x00;
     sendbuffer[8] = 0x00;
     sendbuffer[9] = 0x00;
     sendbuffer[10] = 0xFF;
     sendbuffer[11] = 0xFF;
     BTLEserial.write(sendbuffer, 12);

}

void timelapse(){
            if(startStep < endStep){
              microstepper.move((long)totalStep*(-16.0));
            }
            else if(startStep > endStep){
              microstepper.move((long)totalStep*(16.0));
            }     
            while(microstepper.distanceToGo() != 0){
               microstepper.run();
               BTLEserial.pollACI();
               if(BTLEserial.available()){
                    bluRead();
               }
               if((command == 0x01)||(mode != 0x01)){   // Generic Stop command or Mode change
                    error = 0x22;
                 //   Serial.println("Time Lapse Broke");
                    mode = 0xAA;
                    return;
               }       
            }
           if(loopC == 0x01){
              if(startStep < endStep){
              microstepper.moveTo((long)startStep*(16.0));
            }
            else if(startStep > endStep){
              microstepper.moveTo((long)startStep*(-16.0));
            }  
            // Serial.println("Entered Backward Operation");    
              while(microstepper.distanceToGo() != 0){
              microstepper.run();
              BTLEserial.pollACI();
              if(BTLEserial.available()){
                    bluRead();
              }
              if((command == 0x01)||(mode != 0x01)){   // Generic Stop command or Mode change
                    error = 0x22;
                  //  Serial.println("Time Lapse Broke");
                    mode = 0xAA;
                    return;
                }       
              }
          // LANC Stop Recording
             }
             mode = 0xAA;
             return;
}

void stopmotion(){
    // Serial.println("Entered Stop-Motion Function");
    do{
            if(stepCount < endStep){
              stepper.moveTo((long)stepCount);
            }
            else if(stepCount > endStep){
              stepper.moveTo((long)(-1)*stepCount);
            }
            stepper.runToPosition();
            delay(1000);
            REC();
            Serial.println(loopC);
            delay(loopC*1000);
            stepCount = stepCount + totalStep;
            BTLEserial.pollACI();
            if(BTLEserial.available()){
                 bluRead();
            }
            if((command == 0x01)||(mode != 0x02)){   // Generic Stop command or Mode change
                 error = 0x22;
                 mode = 0xAA;
                 return;
            }  
    }while(abs(stepCount) < abs(endStep));    
            mode = 0xAA;
            return;
}
       

void REC() {
  digitalWrite(4, HIGH); //set LANC line to +5V
  delay(30);
  digitalWrite(4, LOW);
}
  /*
  i = 0;
  while (i < 5) {  //repeat 5 times to make sure the camera accepts the command
      while (pulseIn(5, HIGH) < 5000) {   
      //"pulseIn, HIGH" catches any 0V TO +5V TRANSITION and waits until the LANC line goes back to 0V 
      //"pulseIn" also returns the pulse duration so we can check if the previous +5V duration was long enough (>5ms) to be the pause before a new 8 byte data packet
      // Loop until pulse duration is >5ms
      }

      //LOW after long pause means the START bit of Byte 0 is here
      delayMicroseconds(96);  //wait START bit duration
      
      //Write the 8 bits of byte 0   
      //"18hex" or “00011000”  tells the camera that there will be a normal command to camera in the next byte
      //Note that the command bits have to be put out in reverse order with the least significant, right-most bit (bit 0) first
      //39hex or 00111001
      digitalWrite(4, LOW);  //Write bit 0. 
      delayMicroseconds(96); 
      digitalWrite(4, LOW);  //Write bit 1 
      delayMicroseconds(96);  
      digitalWrite(4, LOW);  //Write bit 2
      delayMicroseconds(96); 
      digitalWrite(4, HIGH);  //Write bit 3
      delayMicroseconds(96);  
      digitalWrite(4, HIGH);  //Write bit 4
      delayMicroseconds(96);
      digitalWrite(4, LOW);  //Write bit 5 
      delayMicroseconds(96);
      digitalWrite(4, LOW);  //Write bit 6
      delayMicroseconds(96); 
      digitalWrite(4, LOW);  //Write bit 7
      delayMicroseconds(96);
      //Byte 0 is written now put LANC line back to +5V
      digitalWrite(4, LOW);
      delayMicroseconds(10); //make sure to be in the stop bit before byte 1

      while (digitalRead(5)) { 
      //Loop as long as the LANC line is +5V during the stop bit
      }

      //0V after the previous stop bit means the START bit of Byte 1 is here
      delayMicroseconds(96);  //wait START bit duration

      //Write the 8 bits of Byte 1
      //"33hex" or “00110011” sends the  Record Start/Stop command
      //Note that the command bits have to be put out in reverse order with the least significant, right-most bit (bit 0) first
      digitalWrite(4, HIGH);  //Write bit 0 
      delayMicroseconds(96);
      digitalWrite(4, HIGH);  //Write bit 1 
      delayMicroseconds(96); 
      digitalWrite(4, LOW);  //Write bit 2
      delayMicroseconds(96); 
      digitalWrite(4, LOW);  //Write bit 3
      delayMicroseconds(96);
      digitalWrite(4, HIGH);  //Write bit 4 
      delayMicroseconds(96); 
      digitalWrite(4, HIGH);  //Write bit 5
      delayMicroseconds(96);
      digitalWrite(4, LOW);  //Write bit 6
      delayMicroseconds(96);
      digitalWrite(4, LOW);  //Write bit 7
      delayMicroseconds(96);
      //Byte 1 is written now put LANC line back to +5V
      digitalWrite(4, LOW); 
      i++;  //increase repeat count by 1
      Serial.println("end write");
  }
}
      /*Control bytes 0 and 1 are written, now don’t care what happens in Bytes 2 to 7
      and just wait for the next start bit after a long pause to send the first two command bytes again.
      }//While cmdRepeatCount < 5
 */
/******End of code***********************************************/
/****************************************************************/
/* Error Codes
0xDC - Bluetooth Disconnect
0x44 - Overshoot # of steps
0x22 - Generic Break Command
*/
